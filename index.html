<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <title>Mappa Esagoni</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #f0f2f5;
      --text: #222;
      --stroke: #333;
      --shadow: 2px 2px 6px rgba(0,0,0,0.35);
    }
    .dark {
      --bg: #121212;
      --text: #eee;
      --stroke: #ddd;
      --shadow: 2px 2px 8px rgba(0,0,0,0.6);
    }

    body {
      margin:0; background:var(--bg); color:var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      display:flex; flex-direction:column; gap:10px; align-items:center;
      min-height:100vh;
    }

    .toolbar {
      display:flex; gap:8px; align-items:center; justify-content:center;
      padding:10px 12px; position:sticky; top:0; z-index:10;
      backdrop-filter:saturate(1.2) blur(6px);
    }

    button {
      border:0; border-radius:10px; padding:10px 14px; font-size:16px;
      box-shadow: var(--shadow); background:#1e88e5; color:#fff; cursor:pointer;
    }
    button.secondary { background:#6c757d; }
    button:hover { filter:brightness(0.95); }

    /* L'SVG occupa praticamente tutto lo schermo */
    #canvas {
      width: 100vw;
      height: calc(100vh - 70px); /* lascia spazio alla toolbar */
      background: transparent;
    }

    polygon {
      stroke: var(--stroke);
      stroke-width: 2;
      opacity: 0;
      transform: scale(0.85);
      transition: transform .45s ease, opacity .45s ease;
    }
    polygon.appear { opacity:1; transform: scale(1); }

    /* Le dimensioni del testo ora le imposto via attribute (scalano col viewBox).
       Qui rimangono solo stile/contorno. */
    text {
      font-weight: 800;
      text-anchor: middle; dominant-baseline: middle;
      paint-order: stroke; stroke: rgba(0,0,0,0.85); stroke-width: 3px;
      stroke-linejoin: round; fill: #fff; pointer-events:none;
    }

    .outerHex {
      fill: white;
      stroke: black;
      stroke-width: 6;
      filter: drop-shadow(0 4px 10px rgba(0,0,0,0.6));
    }

    #note { font:14px/1.4 system-ui, sans-serif; opacity:0.85; margin-bottom:8px; text-align:center; }
  </style>
</head>
<body>
  <div class="toolbar">
    <button id="regen">🔄 Rigenera</button>
    <button id="toggle" class="secondary">🌓 Light/Dark</button>
  </div>

  <!-- niente viewBox fisso: lo settiamo via JS in base alla geometria -->
  <svg id="canvas" preserveAspectRatio="xMidYMid meet"></svg>
  <div id="note"></div>

  <script>
    const svg = document.getElementById("canvas");
    const note = document.getElementById("note");
    const btnRegen = document.getElementById("regen");
    const btnToggle = document.getElementById("toggle");

    // === PARAMETRI LOGICI ===
    const ROT_DEG = -45; // rotazione globale
    const R = 100;       // raggio "unitario" usato per calcolare punti; verrà tutto scalato via viewBox
    const internalColors = ["green","yellow","red","purple","blue","grey"];

    // 19 esagoni (centro + 2 anelli) in coordinate assiali (pointy-top)
    const hexCoords = [
      [0,0],
      [1,0],[1,-1],[0,-1],[-1,0],[-1,1],[0,1],
      [2,0],[2,-1],[2,-2],[1,-2],[0,-2],[-1,-1],
      [-2,0],[-2,1],[-2,2],[-1,2],[0,2],[1,1]
    ];
    // 4 esagoni esterni (A,B,C,D) posizionati simmetricamente
    const outerHexCoords = [[1,-3],[3,-1],[-1,3],[-3,1]];

    // --- Geometria ---
    function axialToPixel(q,r,s){ return [ s*Math.sqrt(3)*(q + r/2), s*1.5*r ]; }
    function rotate(x, y, deg){
      const a = deg*Math.PI/180, cs=Math.cos(a), sn=Math.sin(a);
      return [ x*cs - y*sn, x*sn + y*cs ];
    }
    function hexVertices(cx, cy, r){ // vertici NON ruotati
      const pts=[]; 
      for(let i=0;i<6;i++){
        const a=Math.PI/3*i + Math.PI/6;
        pts.push([cx + r*Math.cos(a), cy + r*Math.sin(a)]);
      }
      return pts;
    }

    // --- Utility ---
    function hexDist(q1,r1,q2,r2){
      return (Math.abs(q1-q2)+Math.abs(r1-r2)+Math.abs((-q1-r1)-(-q2-r2)))/2;
    }
    function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }

    // Palette: nero al centro; 6 colori distinti sul primo anello; ciascun colore totale = 3 (1+2)
    function generatePalette(){
      const pal=["black"];
      const first=shuffle([...internalColors]); // primo anello: tutti diversi
      pal.push(...first);
      const rest=[]; internalColors.forEach(c=>rest.push(c,c)); // due copie per l'anello esterno
      pal.push(...shuffle(rest));
      return pal; // totale 19
    }
    function buildColorMap(pal){ const m=new Map(); hexCoords.forEach(([q,r],i)=>m.set(`${q},${r}`, pal[i])); return m; }

    // Regola dei due passi: dalla stanza di partenza (A,B,C,D) entro distanza ≤2 non devono esistere duplicati di colore
    function validFrom(colorMap, Q, R){
      const seen = new Set();
      for(const [hq,hr] of hexCoords){
        if (hexDist(Q,R,hq,hr) <= 2){
          const c = colorMap.get(`${hq},${hr}`);
          if (seen.has(c)) return false;
          seen.add(c);
        }
      }
      return true;
    }

    function drawHexes(){
      svg.innerHTML=""; note.textContent="";

      // Etichette A–D mescolate (posizioni fisse, lettere cambiano)
      const labels = shuffle(["A","B","C","D"]);
      const starts = {}; labels.forEach((lab,i)=>{ starts[lab]=outerHexCoords[i]; });

      // Ricerca configurazione valida
      let attempts=0, ok=false, palette, cmap;
      const MAX=400000;
      while(attempts<MAX){
        attempts++;
        palette = generatePalette();
        cmap = buildColorMap(palette);
        if (labels.every(lab => { const [Q,R]=starts[lab]; return validFrom(cmap,Q,R); })){
          ok=true; break;
        }
      }
      note.textContent = ok
        ? `✅ Configurazione valida dopo ${attempts} tentativi.`
        : `⚠️ Nessuna configurazione valida entro ${MAX} tentativi.`;

      // --- Costruzione geometria ruotata per bounding e disegno ---
      const polys = []; // {points: [[x,y]...], fill, label?, labelColor?, big?, huge?}
      const texts = [];

      // 19 interni
      let thronePlaced=false;
      hexCoords.forEach(([q,r],i)=>{
        const color = palette[i];
        const [cx,cy] = axialToPixel(q,r,R);
        const [rx,ry] = rotate(cx,cy,ROT_DEG);
        const verts = hexVertices(cx,cy,R).map(([vx,vy])=> rotate(vx,vy,ROT_DEG));
        polys.push({ points: verts, fill: color, outer:false });

        // Etichette dinamiche con font-size proporzionale
        if (q===0 && r===0){ // centro
          texts.push({ x: rx, y: ry, text:"Rosa Nera", size: R*0.55, color:"#fff" });
        } else if (!thronePlaced && Math.abs(q)+Math.abs(r)===1 && (color==="purple" || color==="violet")) {
          thronePlaced=true;
          texts.push({ x: rx, y: ry, text:"Sala Trono", size: R*0.50, color:"#fff" });
        }
      });

      // 4 esterni A–D
      outerHexCoords.forEach(([q,r],i)=>{
        const label = labels[i];
        const [cx,cy] = axialToPixel(q,r,R);
        const [rx,ry] = rotate(cx,cy,ROT_DEG);
        const verts = hexVertices(cx,cy,R).map(([vx,vy])=> rotate(vx,vy,ROT_DEG));
        polys.push({ points: verts, fill: "white", outer:true });
        texts.push({ x: rx, y: ry, text: label, size: R*0.90, color:"#000" });
      });

      // --- Calcolo bounding box su tutti i vertici (già ruotati) ---
      let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
      for (const p of polys){
        for (const [x,y] of p.points){
          if (x<minX) minX=x; if (x>maxX) maxX=x;
          if (y<minY) minY=y; if (y>maxY) maxY=y;
        }
      }
      const PAD = R*0.25; // piccolo margine
      const vbX = minX - PAD, vbY = minY - PAD, vbW = (maxX - minX) + 2*PAD, vbH = (maxY - minY) + 2*PAD;
      svg.setAttribute("viewBox", `${vbX} ${vbY} ${vbW} ${vbH}`);

      // --- Disegno (poligoni poi testi) ---
      for (let i=0;i<polys.length;i++){
        const p = polys[i];
        const poly=document.createElementNS("http://www.w3.org/2000/svg","polygon");
        poly.setAttribute("points", p.points.map(([x,y])=>`${x},${y}`).join(" "));
        if (p.outer) {
          poly.setAttribute("class","outerHex");
        } else {
          poly.setAttribute("fill", p.fill);
          poly.setAttribute("stroke", "var(--stroke)");
          poly.setAttribute("stroke-width", "2");
        }
        svg.appendChild(poly);
        setTimeout(()=>poly.classList.add("appear"), i*30);
      }

      for (const t of texts){
        const el=document.createElementNS("http://www.w3.org/2000/svg","text");
        el.setAttribute("x", t.x); el.setAttribute("y", t.y);
        el.setAttribute("font-size", t.size); // scala con il viewBox
        el.setAttribute("fill", t.color);
        el.textContent = t.text;
        svg.appendChild(el);
      }
    }

    btnRegen.addEventListener("click", drawHexes);
    btnToggle.addEventListener("click", ()=>{ document.body.classList.toggle("dark"); });

    // Ridisegna anche al resize (cambia solo il modo in cui il browser adatta il viewBox)
    window.addEventListener("resize", drawHexes);

    drawHexes();
  </script>
</body>
</html>

